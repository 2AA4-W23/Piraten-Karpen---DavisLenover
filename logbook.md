2023-01-09: Created logbook and begun overview of project. Completed up to task #1 of Step 2. I will leave my answers for now and as the project further progresses, make further changes.
2023-01-10: Implemented player object and added all necessary components to which a player of the game would need (dice, rolling dice, the result of said roll, adding points, subtracting points). As a result, F01 and F02 are complete
2023-01-11: Continued to work on the player class. I ended up deciding on using ArrayList instead of just regular arrays as my initial design ideas included dynamically adding a removing things (such as Dice) from arrays, so to save time it makes more sense to use ArrayLists. Some code had to be changed to accommodate ArrayLists
2023-01-11 (2): Almost all features still needed to be implemented are implemented. Going to run some quick tests to make sure that the features are working as intended before marking as completed with tags. For now, pushing my work.
2023-01-12: All business logic has completed testing and thus has been implemented! Had to re-write my random keeping of dice method as it was really messy. There was also an unforeseen bug which caused the player's current roll not to update when a skull(s) was rolled. The intended logic was to immediately place all skulls to the side upon rolling (which current roll indicates the dice still in play). This has since been fixed. I have also updated the README feature list to streamline feature wording.
2023-01-16: Started repaying debt. I am starting on the MainGame class first as it's the thing that is the most non-generic. Started changing code for methods to be more generic, I will push for now even though the code is non-functional
2023-01-17: MainGame class (now renamed Game) is much more generic and object-oriented, I have implemented new methods such as getting win conditioned players to make code much more organized and readable. Introduced Tracker class which handles printing of simulation results.
2023-01-17 (2): I have made the player class abstract as I figured to make the code more legible and more generic, it made sense to allow programmers to use the Player class as a blueprint for creating specific strategies.
